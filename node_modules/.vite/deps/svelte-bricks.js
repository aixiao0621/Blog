import {
  flip
} from "./chunk-6UPPRBZN.js";
import {
  fade
} from "./chunk-ZV4VB7LQ.js";
import "./chunk-UT2WB5VD.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  add_resize_listener,
  add_transform,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_element,
  claim_space,
  create_animation,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  fix_and_outro_and_destroy_block,
  fix_position,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  noop,
  outro_and_destroy_block,
  safe_not_equal,
  set_style,
  space,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots
} from "./chunk-FBYKLJTS.js";

// node_modules/.pnpm/svelte-bricks@0.1.7/node_modules/svelte-bricks/Masonry.svelte
var file = "node_modules/.pnpm/svelte-bricks@0.1.7/node_modules/svelte-bricks/Masonry.svelte";
function add_css(target) {
  append_styles(target, "svelte-11e8svk", ".svelte-11e8svk:where(div.masonry){display:flex;justify-content:center;overflow-wrap:anywhere;box-sizing:border-box}.svelte-11e8svk:where(div.masonry div.col){display:grid;height:max-content;width:100%}.svelte-11e8svk{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFzb25yeS5zdmVsdGUiLCJtYXBwaW5ncyI6ImVBQ0UsT0FBTyxXQUFXLENBQUMsQUFBQyxDQUFBLEFBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsVUFBVSxDQUFFLFVBQVUsQUFDeEIsQ0FBQSxlQUNBLE9BQU8sbUJBQW1CLENBQUMsQUFBQyxDQUFBLEFBQzFCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLFdBQVcsQ0FDbkIsS0FBSyxDQUFFLElBQUksQUFDYixDQUFBLGlCQUNGIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1hc29ucnkuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
var get_default_slot_changes_1 = (dirty) => ({
  idx: dirty & 1024,
  item: dirty & 1024
});
var get_default_slot_context_1 = (ctx) => ({
  idx: ctx[22],
  item: ctx[21]
});
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({
  idx: dirty & 1024,
  item: dirty & 1024
});
var get_default_slot_context = (ctx) => ({
  idx: ctx[22],
  item: ctx[21]
});
function create_else_block(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[18];
  validate_each_argument(each_value_2);
  const get_key = (ctx2) => ctx2[8](ctx2[21]);
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 34048) {
        each_value_2 = ctx2[18];
        validate_each_argument(each_value_2);
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(64:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[18];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[8](ctx2[21]);
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 34112) {
        each_value_1 = ctx2[18];
        validate_each_argument(each_value_1);
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(54:6) {#if animate}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let current;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], get_default_slot_context_1);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33792)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[15],
            !current ? get_all_dirty_from_scope(ctx[15]) : get_slot_changes(default_slot_template, ctx[15], dirty, get_default_slot_changes_1),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(65:8) {#each col as [item, idx] (getId(item))}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let div;
  let t;
  let div_intro;
  let div_outro;
  let rect;
  let stop_animation = noop;
  let current;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], get_default_slot_context);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-11e8svk");
      add_location(div, file, 55, 10, 1650);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33792)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[15],
            !current ? get_all_dirty_from_scope(ctx[15]) : get_slot_changes(default_slot_template, ctx[15], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
    },
    r: function measure() {
      rect = div.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div);
      stop_animation();
      add_transform(div, rect);
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, { duration: ctx[6] });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, fade, {
            delay: 100,
            duration: ctx[6]
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, fade, { delay: 0, duration: ctx[6] });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(55:8) {#each col as [item, idx] (getId(item))}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "col " + ctx[7] + " svelte-11e8svk");
      set_style(div, "gap", ctx[3] + "px");
      set_style(div, "max-width", ctx[2] + "px");
      add_location(div, file, 52, 4, 1489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t);
      }
      if (!current || dirty & 128 && div_class_value !== (div_class_value = "col " + ctx2[7] + " svelte-11e8svk")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 8) {
        set_style(div, "gap", ctx2[3] + "px");
      }
      if (!current || dirty & 4) {
        set_style(div, "max-width", ctx2[2] + "px");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(52:2) {#each itemsToCols as col}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let div_resize_listener;
  let current;
  let each_value = ctx[10];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "masonry " + ctx[9] + " svelte-11e8svk");
      attr_dev(div, "style", div_style_value = "gap: " + ctx[3] + "px; " + ctx[5]);
      add_render_callback(() => ctx[17].call(div));
      add_location(div, file, 45, 0, 1317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      div_resize_listener = add_resize_listener(div, ctx[17].bind(div));
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 34012) {
        each_value = ctx2[10];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 512 && div_class_value !== (div_class_value = "masonry " + ctx2[9] + " svelte-11e8svk")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 40 && div_style_value !== (div_style_value = "gap: " + ctx2[3] + "px; " + ctx2[5])) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let nCols;
  let itemsToCols;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Masonry", slots, ["default"]);
  let { items } = $$props;
  let { minColWidth = 330 } = $$props;
  let { maxColWidth = 500 } = $$props;
  let { gap = 20 } = $$props;
  let { masonryWidth = 0 } = $$props;
  let { masonryHeight = 0 } = $$props;
  let { animate = true } = $$props;
  let { style = `` } = $$props;
  let { duration = 200 } = $$props;
  let { columnClass = `` } = $$props;
  let { idKey = `id` } = $$props;
  let { getId = (item) => {
    if (typeof item === `string`)
      return item;
    if (typeof item === `number`)
      return item;
    return item[idKey];
  } } = $$props;
  let { class: className = `` } = $$props;
  $$self.$$.on_mount.push(function() {
    if (items === void 0 && !("items" in $$props || $$self.$$.bound[$$self.$$.props["items"]])) {
      console.warn("<Masonry> was created without expected prop 'items'");
    }
  });
  const writable_props = [
    "items",
    "minColWidth",
    "maxColWidth",
    "gap",
    "masonryWidth",
    "masonryHeight",
    "animate",
    "style",
    "duration",
    "columnClass",
    "idKey",
    "getId",
    "class"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Masonry> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    masonryWidth = this.clientWidth;
    masonryHeight = this.clientHeight;
    $$invalidate(0, masonryWidth);
    $$invalidate(1, masonryHeight);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("minColWidth" in $$props2)
      $$invalidate(12, minColWidth = $$props2.minColWidth);
    if ("maxColWidth" in $$props2)
      $$invalidate(2, maxColWidth = $$props2.maxColWidth);
    if ("gap" in $$props2)
      $$invalidate(3, gap = $$props2.gap);
    if ("masonryWidth" in $$props2)
      $$invalidate(0, masonryWidth = $$props2.masonryWidth);
    if ("masonryHeight" in $$props2)
      $$invalidate(1, masonryHeight = $$props2.masonryHeight);
    if ("animate" in $$props2)
      $$invalidate(4, animate = $$props2.animate);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
    if ("duration" in $$props2)
      $$invalidate(6, duration = $$props2.duration);
    if ("columnClass" in $$props2)
      $$invalidate(7, columnClass = $$props2.columnClass);
    if ("idKey" in $$props2)
      $$invalidate(13, idKey = $$props2.idKey);
    if ("getId" in $$props2)
      $$invalidate(8, getId = $$props2.getId);
    if ("class" in $$props2)
      $$invalidate(9, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    flip,
    fade,
    items,
    minColWidth,
    maxColWidth,
    gap,
    masonryWidth,
    masonryHeight,
    animate,
    style,
    duration,
    columnClass,
    idKey,
    getId,
    className,
    nCols,
    itemsToCols
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("minColWidth" in $$props2)
      $$invalidate(12, minColWidth = $$props2.minColWidth);
    if ("maxColWidth" in $$props2)
      $$invalidate(2, maxColWidth = $$props2.maxColWidth);
    if ("gap" in $$props2)
      $$invalidate(3, gap = $$props2.gap);
    if ("masonryWidth" in $$props2)
      $$invalidate(0, masonryWidth = $$props2.masonryWidth);
    if ("masonryHeight" in $$props2)
      $$invalidate(1, masonryHeight = $$props2.masonryHeight);
    if ("animate" in $$props2)
      $$invalidate(4, animate = $$props2.animate);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
    if ("duration" in $$props2)
      $$invalidate(6, duration = $$props2.duration);
    if ("columnClass" in $$props2)
      $$invalidate(7, columnClass = $$props2.columnClass);
    if ("idKey" in $$props2)
      $$invalidate(13, idKey = $$props2.idKey);
    if ("getId" in $$props2)
      $$invalidate(8, getId = $$props2.getId);
    if ("className" in $$props2)
      $$invalidate(9, className = $$props2.className);
    if ("nCols" in $$props2)
      $$invalidate(14, nCols = $$props2.nCols);
    if ("itemsToCols" in $$props2)
      $$invalidate(10, itemsToCols = $$props2.itemsToCols);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6153) {
      $:
        $$invalidate(14, nCols = Math.min(items.length, Math.floor(masonryWidth / (minColWidth + gap)) || 1));
    }
    if ($$self.$$.dirty & 18432) {
      $:
        $$invalidate(10, itemsToCols = items.reduce(
          (cols, item, idx) => {
            cols[idx % cols.length].push([item, idx]);
            return cols;
          },
          Array(nCols).fill(null).map(() => [])
        ));
    }
  };
  return [
    masonryWidth,
    masonryHeight,
    maxColWidth,
    gap,
    animate,
    style,
    duration,
    columnClass,
    getId,
    className,
    itemsToCols,
    items,
    minColWidth,
    idKey,
    nCols,
    $$scope,
    slots,
    div_elementresize_handler
  ];
}
var Masonry = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        items: 11,
        minColWidth: 12,
        maxColWidth: 2,
        gap: 3,
        masonryWidth: 0,
        masonryHeight: 1,
        animate: 4,
        style: 5,
        duration: 6,
        columnClass: 7,
        idKey: 13,
        getId: 8,
        class: 9
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Masonry",
      options,
      id: create_fragment.name
    });
  }
  get items() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minColWidth() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minColWidth(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxColWidth() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxColWidth(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masonryWidth() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masonryWidth(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masonryHeight() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masonryHeight(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnClass() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnClass(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get idKey() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set idKey(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getId(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Masonry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Masonry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Masonry_default = Masonry;
export {
  Masonry_default as default
};
//# sourceMappingURL=svelte-bricks.js.map
