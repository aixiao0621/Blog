/** Object Image */
declare type FFFImage = Partial<HTMLImageElement> & {
    source?: Partial<HTMLSourceElement>[];
    figcaption?: string;
};
/** Object Audio */
declare type FFFAudio = Partial<HTMLAudioElement> & {
    source?: Partial<HTMLSourceElement>[];
};
/** Object Video */
declare type FFFVideo = Partial<HTMLVideoElement> & {
    source?: Partial<HTMLSourceElement>[];
};
/** Author */
declare type FFFAuthor = {
    /** the author's name. */
    name?: string;
    /** the URL of a site owned by the author. */
    url?: string;
    /** the URL for an image for the author. */
    avatar?: string;
};
/** Base Variables */
declare type FFFBase = {
    /** the title of article, non-article posts may omit titles. */
    title?: string;
    /** plain text sentence or two describing the post. */
    summary?: string;
    /** the created date of the post. */
    created?: string;
    /** the updated date of the post. */
    updated?: string;
    /** the published date of the post. */
    published?: string;
    /** the featured image for article, or image for "photo" / "multi-photo" posts. */
    image?: string | FFFImage | string[] | FFFImage[];
    /** the main audio for "audio" post. */
    audio?: string | FFFAudio;
    /** the main video for "video" post. */
    video?: string | FFFVideo;
    /** tags array, any plain text values you want. */
    tags?: string[];
    /** flags array, any plain text values you want. */
    flags?: string[];
};
/** Extra Variables */
declare type FFFExtra = {
    /** specifies one or more post authors. */
    authors?: FFFAuthor[];
    /** the primary language for the post. */
    lang?: string;
    /** location the post was posted from. */
    location?: string;
    /** indicates this post is a bookmark of another URL. */
    bookmark_of?: string;
    /** the URL which the post is considered a "like" (favorite, star) of. */
    like_of?: string;
    /** the URL which the post is considered a "repost" of. */
    repost_of?: string;
    /** URL(s) which the post is considered reply to. */
    in_reply_to?: string | string[];
    /** URL(s) of syndicated copies of this post. */
    syndication?: string | string[];
    /** the URL of the venue/location h-card which the h-entry is considered a "checkin" of. */
    checkin?: string;
    /** a reply to an event that says whether the sender is attending. */
    rsvp?: 'yes' | 'no' | 'maybe' | 'interested';
    /** datetime the event starts. */
    start?: string;
    /** datetime the event ends. */
    end?: string;
};
/** FFF Flavored Frontmatter */
declare type FFFFlavoredFrontmatter = FFFBase & FFFExtra;

// Type definitions for non-npm package Unist 2.0
// Project: https://github.com/syntax-tree/unist
// Definitions by: bizen241 <https://github.com/bizen241>
//                 Jun Lu <https://github.com/lujun2>
//                 Hernan Rajchert <https://github.com/hrajchert>
//                 Titus Wormer <https://github.com/wooorm>
//                 Junyoung Choi <https://github.com/rokt33r>
//                 Ben Moon <https://github.com/GuiltyDolphin>
//                 JounQin <https://github.com/JounQin>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 3.0

/**
 * Syntactic units in unist syntax trees are called nodes.
 *
 * @typeParam TData Information from the ecosystem. Useful for more specific {@link Node.data}.
 */
interface Node<TData extends object = Data$2> {
    /**
     * The variant of a node.
     */
    type: string;

    /**
     * Information from the ecosystem.
     */
    data?: TData | undefined;

    /**
     * Location of a node in a source document.
     * Must not be present if a node is generated.
     */
    position?: Position$2 | undefined;
}

/**
 * Information associated by the ecosystem with the node.
 * Space is guaranteed to never be specified by unist or specifications
 * implementing unist.
 */
interface Data$2 {
    [key: string]: unknown;
}

/**
 * Location of a node in a source file.
 */
interface Position$2 {
    /**
     * Place of the first character of the parsed source region.
     */
    start: Point;

    /**
     * Place of the first character after the parsed source region.
     */
    end: Point;

    /**
     * Start column at each index (plus start line) in the source region,
     * for elements that span multiple lines.
     */
    indent?: number[] | undefined;
}

/**
 * One place in a source file.
 */
interface Point {
    /**
     * Line in a source file (1-indexed integer).
     */
    line: number;

    /**
     * Column in a source file (1-indexed integer).
     */
    column: number;
    /**
     * Character in a source file (0-indexed integer).
     */
    offset?: number | undefined;
}

/**
 * This is the same as `Buffer` if node types are included, `never` otherwise.
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment, @typescript-eslint/prefer-ts-expect-error
// @ts-ignore Itâ€™s important to preserve this ignore statement. This makes sure
// it works both with and without node types.
// eslint-disable-next-line n/prefer-global/buffer
type MaybeBuffer = any extends Buffer ? never : Buffer

/**
 * Contents of the file.
 * Can either be text, or a Buffer like structure.
 * This does not directly use type `Buffer`, because it can also be used in a
 * browser context.
 * Instead this leverages `Uint8Array` which is the base type for `Buffer`,
 * and a native JavaScript construct.
 */
type Value$1 = string | MaybeBuffer

/**
 * This map registers the type of the `data` key of a `VFile`.
 *
 * This type can be augmented to register custom `data` types.
 *
 * @example
 * declare module 'vfile' {
 *   interface DataMap {
 *     // `file.data.name` is typed as `string`
 *     name: string
 *   }
 * }
 */

// eslint-disable-next-line @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-empty-interface
interface DataMap {}

/**
 * Place to store custom information.
 *
 * Known attributes can be added to @see {@link DataMap}
 */
type Data$1 = Record<string, unknown> & Partial<DataMap>

type URL$1 = {
  hash: string
  host: string
  hostname: string
  href: string
  origin: string
  password: string
  pathname: string
  port: string
  protocol: string
  search: string
  searchParams: any
  username: string
  toString: () => string
  toJSON: () => string
}

declare class VFileMessage extends Error {
  /**
   * Constructor of a message for `reason` at `place` from `origin`.
   * When an error is passed in as `reason`, copies the `stack`.
   *
   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
   * @param {string} [origin] Place in code the message originates from (`string`, optional).
   */
  constructor(
    reason: string | Error,
    place?:
      | Node<Data$2>
      | Position$2
      | Point
      | NodeLike$1
      | undefined,
    origin?: string | undefined
  )
  stack: string | undefined
  /**
   * Reason for message.
   * @type {string}
   */
  reason: string
  /**
   * If true, marks associated file as no longer processable.
   * @type {boolean?}
   */
  fatal: boolean | null
  /**
   * Starting line of error.
   * @type {number?}
   */
  line: number | null
  /**
   * Starting column of error.
   * @type {number?}
   */
  column: number | null
  /**
   * Namespace of warning.
   * @type {string?}
   */
  source: string | null
  /**
   * Category of message.
   * @type {string?}
   */
  ruleId: string | null
  /**
   * Full range information, when available.
   * Has start and end properties, both set to an object with line and column, set to number?.
   * @type {Position?}
   */
  position: Position$1 | null
  /**
   * You can use this to specify the source value thatâ€™s being reported, which
   * is deemed incorrect.
   * @type {string?}
   */
  actual: string | null
  /**
   * You can use this to suggest values that should be used instead of
   * `actual`, one or more values that are deemed as acceptable.
   * @type {Array<string>?}
   */
  expected: Array<string> | null
  /**
   * You may add a file property with a path of a file (used throughout the VFile ecosystem).
   * @type {string?}
   */
  file: string | null
  /**
   * You may add a url property with a link to documentation for the message.
   * @type {string?}
   */
  url: string | null
  /**
   * You may add a note property with a long form description of the message (supported by vfile-reporter).
   * @type {string?}
   */
  note: string | null
}
type Position$1 = Position$2
type NodeLike$1 = object & {
  type: string
  position?: Position$1 | undefined
}

declare class VFile {
  /**
   * Create a new virtual file.
   *
   * If `options` is `string` or `Buffer`, itâ€™s treated as `{value: options}`.
   * If `options` is a `URL`, itâ€™s treated as `{path: options}`.
   * If `options` is a `VFile`, shallow copies its data over to the new file.
   * All fields in `options` are set on the newly created `VFile`.
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * Itâ€™s not possible to set either `dirname` or `extname` without setting
   * either `history`, `path`, `basename`, or `stem` as well.
   *
   * @param {Compatible} [value]
   */
  constructor(value?: Compatible | undefined)
  /**
   * Place to store custom information (default: `{}`).
   * Itâ€™s OK to store custom data directly on the file but moving it to
   * `data` is recommended.
   * @type {Data}
   */
  data: Data
  /**
   * List of messages associated with the file.
   * @type {Array<VFileMessage>}
   */
  messages: Array<VFileMessage>
  /**
   * List of filepaths the file moved between.
   * The first is the original path and the last is the current path.
   * @type {Array<string>}
   */
  history: Array<string>
  /**
   * Base of `path` (default: `process.cwd()` or `'/'` in browsers).
   * @type {string}
   */
  cwd: string
  /**
   * Raw value.
   * @type {Value}
   */
  value: Value
  /**
   * Whether a file was saved to disk.
   * This is used by vfile reporters.
   * @type {boolean}
   */
  stored: boolean
  /**
   * Sometimes files have a non-string, compiled, representation.
   * This can be stored in the `result` field.
   * One example is when turning markdown into React nodes.
   * This is used by unified to store non-string results.
   * @type {unknown}
   */
  result: unknown
  /**
   * Sometimes files have a source map associated with them.
   * This can be stored in the `map` field.
   * This should be a `Map` type, which is equivalent to the `RawSourceMap`
   * type from the `source-map` module.
   * @type {Map|undefined}
   */
  map: Map | undefined
  /**
   * Set the full path (example: `'~/index.min.js'`).
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   * @param {string|URL} path
   */
  set path(arg: string)
  /**
   * Get the full path (example: `'~/index.min.js'`).
   * @returns {string}
   */
  get path(): string
  /**
   * Set the parent path (example: `'~'`).
   * Cannot be set if thereâ€™s no `path` yet.
   */
  set dirname(arg: string | undefined)
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname(): string | undefined
  /**
   * Set basename (including extname) (`'index.min.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(arg: string | undefined)
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename(): string | undefined
  /**
   * Set the extname (including dot) (example: `'.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   */
  set extname(arg: string | undefined)
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname(): string | undefined
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(arg: string | undefined)
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem(): string | undefined
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding} [encoding='utf8']
   *   When `value` is a `Buffer`, `encoding` is a character encoding to
   *   understand it as (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding?: BufferEncoding | undefined): string
  /**
   * Constructs a new `VFileMessage`, where `fatal` is set to `false`, and
   * associates it with the file by adding it to `vfile.messages` and setting
   * `message.file` to the current filepath.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  message(
    reason: string | Error,
    place?:
      | Node<Data$2>
      | Position$2
      | Point
      | NodeLike
      | undefined,
    origin?: string | undefined
  ): VFileMessage
  /**
   * Like `VFile#message()`, but associates an informational message where
   * `fatal` is set to `null`.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  info(
    reason: string | Error,
    place?:
      | Node<Data$2>
      | Position$2
      | Point
      | NodeLike
      | undefined,
    origin?: string | undefined
  ): VFileMessage
  /**
   * Like `VFile#message()`, but associates a fatal message where `fatal` is
   * set to `true`, and then immediately throws it.
   *
   * > ðŸ‘‰ **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string|Error} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {never}
   *   Message.
   */
  fail(
    reason: string | Error,
    place?:
      | Node<Data$2>
      | Position$2
      | Point
      | NodeLike
      | undefined,
    origin?: string | undefined
  ): never
}
type Position = Position$2
type NodeLike = Record<string, unknown> & {
  type: string
  position?: Position | undefined
}
type URL = URL$1
type Data = Data$1
type Value = Value$1
/**
 * Encodings supported by the buffer class.
 * This is a copy of the typing from Node, copied to prevent Node globals from
 * being needed.
 * Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>
 */
type BufferEncoding =
  | 'ascii'
  | 'utf8'
  | 'utf-8'
  | 'utf16le'
  | 'ucs2'
  | 'ucs-2'
  | 'base64'
  | 'base64url'
  | 'latin1'
  | 'binary'
  | 'hex'
/**
 * Things that can be passed to the constructor.
 */
type Compatible = Value | Options | VFile | URL
type VFileCoreOptions = {
  value?: Value$1 | undefined
  cwd?: string | undefined
  history?: string[] | undefined
  path?: string | URL$1 | undefined
  basename?: string | undefined
  stem?: string | undefined
  extname?: string | undefined
  dirname?: string | undefined
  data?: Data$1 | undefined
}
/**
 * Raw source map, see:
 * <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.
 */
type Map = {
  version: number
  sources: Array<string>
  names: Array<string>
  sourceRoot?: string | undefined
  sourcesContent?: Array<string> | undefined
  mappings: string
  file: string
}
/**
 * Configuration: a bunch of keys that will be shallow copied over to the new
 * file.
 */
type Options = {
  [key: string]: unknown
} & VFileCoreOptions

// TypeScript Version: 4.0


/* eslint-disable @typescript-eslint/naming-convention */

type VFileWithOutput<Result> = Result extends Uint8Array // Buffer.
  ? VFile
  : Result extends object // Custom result type
  ? VFile & {result: Result}
  : VFile

// Get the right most non-void thing.
type Specific<Left = void, Right = void> = Right extends void ? Left : Right

// Create a processor based on the input/output of a plugin.
type UsePlugin<
  ParseTree extends Node | void = void,
  CurrentTree extends Node | void = void,
  CompileTree extends Node | void = void,
  CompileResult = void,
  Input = void,
  Output = void
> = Output extends Node
  ? Input extends string
    ? // If `Input` is `string` and `Output` is `Node`, then this plugin
      // defines a parser, so set `ParseTree`.
      Processor<
        Output,
        Specific<Output, CurrentTree>,
        Specific<Output, CompileTree>,
        CompileResult
      >
    : Input extends Node
    ? // If `Input` is `Node` and `Output` is `Node`, then this plugin defines a
      // transformer, its output defines the input of the next, so set
      // `CurrentTree`.
      Processor<
        Specific<Input, ParseTree>,
        Output,
        Specific<CompileTree, Output>,
        CompileResult
      >
    : // Else, `Input` is something else and `Output` is `Node`:
      never
  : Input extends Node
  ? // If `Input` is `Node` and `Output` is not a `Node`, then this plugin
    // defines a compiler, so set `CompileTree` and `CompileResult`
    Processor<
      Specific<Input, ParseTree>,
      Specific<Input, CurrentTree>,
      Input,
      Output
    >
  : // Else, `Input` is not a `Node` and `Output` is not a `Node`.
    // Maybe itâ€™s untyped, or the plugin throws an error (`never`), so lets
    // just keep it as it was.
    Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

/* eslint-enable @typescript-eslint/naming-convention */

/**
 * Processor allows plugins to be chained together to transform content.
 * The chain of plugins defines how content flows through it.
 *
 * @typeParam ParseTree
 *   The node that the parser yields (and `run` receives).
 * @typeParam CurrentTree
 *   The node that the last attached plugin yields.
 * @typeParam CompileTree
 *   The node that the compiler receives (and `run` yields).
 * @typeParam CompileResult
 *   The thing that the compiler yields.
 */
interface Processor<
  ParseTree extends Node | void = void,
  CurrentTree extends Node | void = void,
  CompileTree extends Node | void = void,
  CompileResult = void
> extends FrozenProcessor<ParseTree, CurrentTree, CompileTree, CompileResult> {
  /**
   * Configure the processor to use a plugin.
   *
   * @typeParam PluginParameters
   *   Plugin settings.
   * @typeParam Input
   *   Value that is accepted by the plugin.
   *
   *   *   If the plugin returns a transformer, then this should be the node
   *       type that the transformer expects.
   *   *   If the plugin sets a parser, then this should be `string`.
   *   *   If the plugin sets a compiler, then this should be the node type that
   *       the compiler expects.
   * @typeParam Output
   *   Value that the plugin yields.
   *
   *   *   If the plugin returns a transformer, then this should be the node
   *       type that the transformer yields, and defaults to `Input`.
   *   *   If the plugin sets a parser, then this should be the node type that
   *       the parser yields.
   *   *   If the plugin sets a compiler, then this should be the result that
   *       the compiler yields (`string`, `Buffer`, or something else).
   * @param plugin
   *   Plugin (function) to use.
   *   Plugins are deduped based on identity: passing a function in twice will
   *   cause it to run only once.
   * @param settings
   *   Configuration for plugin, optional.
   *   Plugins typically receive one options object, but could receive other and
   *   more values.
   *   Itâ€™s also possible to pass a boolean instead of settings: `true` (to turn
   *   a plugin on) or `false` (to turn a plugin off).
   * @returns
   *   Current processor.
   */
  use<
    PluginParameters extends any[] = any[],
    Input = Specific<Node, CurrentTree>,
    Output = Input
  >(
    plugin: Plugin$1<PluginParameters, Input, Output>,
    ...settings: PluginParameters | [boolean]
  ): UsePlugin<
    ParseTree,
    CurrentTree,
    CompileTree,
    CompileResult,
    Input,
    Output
  >

  /**
   * Configure the processor with a tuple of a plugin and setting(s).
   *
   * @typeParam PluginParameters
   *   Plugin settings.
   * @typeParam Input
   *   Value that is accepted by the plugin.
   *
   *   *   If the plugin returns a transformer, then this should be the node
   *       type that the transformer expects.
   *   *   If the plugin sets a parser, then this should be `string`.
   *   *   If the plugin sets a compiler, then this should be the node type that
   *       the compiler expects.
   * @typeParam Output
   *   Value that the plugin yields.
   *
   *   *   If the plugin returns a transformer, then this should be the node
   *       type that the transformer yields, and defaults to `Input`.
   *   *   If the plugin sets a parser, then this should be the node type that
   *       the parser yields.
   *   *   If the plugin sets a compiler, then this should be the result that
   *       the compiler yields (`string`, `Buffer`, or something else).
   * @param tuple
   *   A tuple where the first item is a plugin (function) to use and other
   *   items are options.
   *   Plugins are deduped based on identity: passing a function in twice will
   *   cause it to run only once.
   *   Itâ€™s also possible to pass a boolean instead of settings: `true` (to turn
   *   a plugin on) or `false` (to turn a plugin off).
   * @returns
   *   Current processor.
   */
  use<
    PluginParameters extends any[] = any[],
    Input = Specific<Node, CurrentTree>,
    Output = Input
  >(
    tuple:
      | PluginTuple<PluginParameters, Input, Output>
      | [Plugin$1<PluginParameters, Input, Output>, boolean]
  ): UsePlugin<
    ParseTree,
    CurrentTree,
    CompileTree,
    CompileResult,
    Input,
    Output
  >

  /**
   * Configure the processor with a preset or list of plugins and presets.
   *
   * @param presetOrList
   *   Either a list of plugins, presets, and tuples, or a single preset: an
   *   object with a `plugins` (list) and/or `settings`
   *   (`Record<string, unknown>`).
   * @returns
   *   Current processor.
   */
  use(
    presetOrList: Preset | PluggableList
  ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>
}

/**
 * A frozen processor is just like a regular processor, except no additional
 * plugins can be added.
 * A frozen processor can be created by calling `.freeze()` on a processor.
 * An unfrozen processor can be created by calling a processor.
 */
interface FrozenProcessor<
  ParseTree extends Node | void = void,
  CurrentTree extends Node | void = void,
  CompileTree extends Node | void = void,
  CompileResult = void
> {
  /**
   * Clone current processor
   *
   * @returns
   *   New unfrozen processor that is configured to function the same as its
   *   ancestor.
   *   But when the descendant processor is configured it does not affect the
   *   ancestral processor.
   */
  (): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

  /**
   * Internal list of configured plugins.
   *
   * @private
   */
  attachers: Array<[Plugin$1, ...unknown[]]>

  Parser?: Parser<Specific<Node, ParseTree>> | undefined
  Compiler?:
    | Compiler<Specific<Node, CompileTree>, Specific<unknown, CompileResult>>
    | undefined

  /**
   * Parse a file.
   *
   * @param file
   *   File to parse.
   *   `VFile` or anything that can be given to `new VFile()`, optional.
   * @returns
   *   Resulting tree.
   */
  parse(file?: Compatible | undefined): Specific<Node, ParseTree>

  /**
   * Compile a file.
   *
   * @param node
   *   Node to compile.
   * @param file
   *   `VFile` or anything that can be given to `new VFile()`, optional.
   * @returns
   *   New content: compiled text (`string` or `Buffer`) or something else.
   *   This depends on which plugins you use: typically text, but could for
   *   example be a React node.
   */
  stringify(
    node: Specific<Node, CompileTree>,
    file?: Compatible | undefined
  ): CompileTree extends Node ? CompileResult : unknown

  /**
   * Run transforms on the given tree.
   *
   * @param node
   *   Tree to transform.
   * @param callback
   *   Callback called with an error or the resulting node.
   * @returns
   *   Nothing.
   */
  run(
    node: Specific<Node, ParseTree>,
    callback: RunCallback<Specific<Node, CompileTree>>
  ): void

  /**
   * Run transforms on the given node.
   *
   * @param node
   *   Tree to transform.
   * @param file
   *   File associated with `node`.
   *   `VFile` or anything that can be given to `new VFile()`.
   * @param callback
   *   Callback called with an error or the resulting node.
   * @returns
   *   Nothing.
   */
  run(
    node: Specific<Node, ParseTree>,
    file: Compatible | undefined,
    callback: RunCallback<Specific<Node, CompileTree>>
  ): void

  /**
   * Run transforms on the given node.
   *
   * @param node
   *   Tree to transform.
   * @param file
   *   File associated with `node`.
   *   `VFile` or anything that can be given to `new VFile()`.
   * @returns
   *   Promise that resolves to the resulting tree.
   */
  run(
    node: Specific<Node, ParseTree>,
    file?: Compatible | undefined
  ): Promise<Specific<Node, CompileTree>>

  /**
   * Run transforms on the given node, synchronously.
   * Throws when asynchronous transforms are configured.
   *
   * @param node
   *   Tree to transform.
   * @param file
   *   File associated with `node`.
   *   `VFile` or anything that can be given to `new VFile()`, optional.
   * @returns
   *   Resulting tree.
   */
  runSync(
    node: Specific<Node, ParseTree>,
    file?: Compatible | undefined
  ): Specific<Node, CompileTree>

  /**
   * Process a file.
   *
   * This performs all phases of the processor:
   *
   * 1.  Parse a file into a unist node using the configured `Parser`
   * 2.  Run transforms on that node
   * 3.  Compile the resulting node using the `Compiler`
   *
   * The result from the compiler is stored on the file.
   * What the result is depends on which plugins you use.
   * The result is typically text (`string` or `Buffer`), which can be retrieved
   * with `file.toString()` (or `String(file)`).
   * In some cases, such as when using `rehypeReact` to create a React node,
   * the result is stored on `file.result`.
   *
   * @param file
   *   `VFile` or anything that can be given to `new VFile()`.
   * @param callback
   *   Callback called with an error or the resulting file.
   * @returns
   *   Nothing.
   */
  process(
    file: Compatible | undefined,
    callback: ProcessCallback<VFileWithOutput<CompileResult>>
  ): void

  /**
   * Process a file.
   *
   * This performs all phases of the processor:
   *
   * 1.  Parse a file into a unist node using the configured `Parser`
   * 2.  Run transforms on that node
   * 3.  Compile the resulting node using the `Compiler`
   *
   * The result from the compiler is stored on the file.
   * What the result is depends on which plugins you use.
   * The result is typically text (`string` or `Buffer`), which can be retrieved
   * with `file.toString()` (or `String(file)`).
   * In some cases, such as when using `rehypeReact` to create a React node,
   * the result is stored on `file.result`.
   *
   * @param file
   *   `VFile` or anything that can be given to `new VFile()`.
   * @returns
   *   Promise that resolves to the resulting `VFile`.
   */
  process(file: Compatible): Promise<VFileWithOutput<CompileResult>>

  /**
   * Process a file, synchronously.
   * Throws when asynchronous transforms are configured.
   *
   * This performs all phases of the processor:
   *
   * 1.  Parse a file into a unist node using the configured `Parser`
   * 2.  Run transforms on that node
   * 3.  Compile the resulting node using the `Compiler`
   *
   * The result from the compiler is stored on the file.
   * What the result is depends on which plugins you use.
   * The result is typically text (`string` or `Buffer`), which can be retrieved
   * with `file.toString()` (or `String(file)`).
   * In some cases, such as when using `rehypeReact` to create a React node,
   * the result is stored on `file.result`.
   *
   * @param file
   *   `VFile` or anything that can be given to `new VFile()`, optional.
   * @returns
   *   Resulting file.
   */
  processSync(
    file?: Compatible | undefined
  ): VFileWithOutput<CompileResult>

  /**
   * Get an in-memory key-value store accessible to all phases of the process.
   *
   * @returns
   *   Key-value store.
   */
  data(): Record<string, unknown>

  /**
   * Set an in-memory key-value store accessible to all phases of the process.
   *
   * @param data
   *   Key-value store.
   * @returns
   *   Current processor.
   */
  data(
    data: Record<string, unknown>
  ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

  /**
   * Get an in-memory value by key.
   *
   * @param key
   *   Key to get.
   * @returns
   *   The value at `key`.
   */
  data(key: string): unknown

  /**
   * Set an in-memory value by key.
   *
   * @param key
   *   Key to set.
   * @param value
   *   Value to set.
   * @returns
   *   Current processor.
   */
  data(
    key: string,
    value: unknown
  ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

  /**
   * Freeze a processor.
   * Frozen processors are meant to be extended and not to be configured or
   * processed directly.
   *
   * Once a processor is frozen it cannot be unfrozen.
   * New processors working just like it can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly, by calling `.freeze()`, but
   * `.parse()`, `.run()`, `.stringify()`, and `.process()` call `.freeze()` to
   * freeze a processor too.
   *
   * @returns
   *   Frozen processor.
   */
  freeze(): FrozenProcessor<ParseTree, CurrentTree, CompileTree, CompileResult>
}

/**
 * A plugin is a function.
 * It configures the processor and in turn can receive options.
 * Plugins can configure processors by interacting with parsers and compilers
 * (at `this.Parser` or `this.Compiler`) or by specifying how the syntax tree
 * is handled (by returning a `Transformer`).
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 * @typeParam Input
 *   Value that is accepted by the plugin.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer expects.
 *   *   If the plugin sets a parser, then this should be `string`.
 *   *   If the plugin sets a compiler, then this should be the node type that
 *       the compiler expects.
 * @typeParam Output
 *   Value that the plugin yields.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer yields, and defaults to `Input`.
 *   *   If the plugin sets a parser, then this should be the node type that
 *       the parser yields.
 *   *   If the plugin sets a compiler, then this should be the result that
 *       the compiler yields (`string`, `Buffer`, or something else).
 * @this
 *   The current processor.
 *   Plugins can configure the processor by interacting with `this.Parser` or
 *   `this.Compiler`, or by accessing the data associated with the whole process
 *   (`this.data`).
 * @param settings
 *   Configuration for plugin.
 *   Plugins typically receive one options object, but could receive other and
 *   more values.
 *   Users can also pass a boolean instead of settings: `true` (to turn
 *   a plugin on) or `false` (to turn a plugin off).
 *   When a plugin is turned off, it wonâ€™t be called.
 *
 *   When creating your own plugins, please accept only a single object!
 *   It allows plugins to be reconfigured and it helps users to know that every
 *   plugin accepts one options object.
 * @returns
 *   Plugins can return a `Transformer` to specify how the syntax tree is
 *   handled.
 */
type Plugin$1<
  PluginParameters extends any[] = any[],
  Input = Node,
  Output = Input
> = (
  this: Input extends Node
    ? Output extends Node
      ? // This is a transform, so define `Input` as the current tree.
        Processor<void, Input>
      : // Compiler.
        Processor<void, Input, Input, Output>
    : Output extends Node
    ? // Parser.
      Processor<Output, Output>
    : // No clue.
      Processor,
  ...settings: PluginParameters
) => // If both `Input` and `Output` are `Node`, expect an optional `Transformer`.
Input extends Node
  ? Output extends Node
    ? Transformer$1<Input, Output> | void
    : void
  : void

/**
 * Presets provide a sharable way to configure processors with multiple plugins
 * and/or settings.
 */
interface Preset {
  plugins?: PluggableList
  settings?: Record<string, unknown>
}

/**
 * A tuple of a plugin and its setting(s).
 * The first item is a plugin (function) to use and other items are options.
 * Plugins are deduped based on identity: passing a function in twice will
 * cause it to run only once.
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 * @typeParam Input
 *   Value that is accepted by the plugin.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer expects.
 *   *   If the plugin sets a parser, then this should be `string`.
 *   *   If the plugin sets a compiler, then this should be the node type that
 *       the compiler expects.
 * @typeParam Output
 *   Value that the plugin yields.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer yields, and defaults to `Input`.
 *   *   If the plugin sets a parser, then this should be the node type that
 *       the parser yields.
 *   *   If the plugin sets a compiler, then this should be the result that
 *       the compiler yields (`string`, `Buffer`, or something else).
 */
type PluginTuple<
  PluginParameters extends any[] = any[],
  Input = Node,
  Output = Input
> = [Plugin$1<PluginParameters, Input, Output>, ...PluginParameters]

/**
 * A union of the different ways to add plugins and settings.
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 */
type Pluggable<PluginParameters extends any[] = any[]> =
  | PluginTuple<PluginParameters, any, any>
  | Plugin$1<PluginParameters, any, any>
  | Preset

/**
 * A list of plugins and presets.
 */
type PluggableList = Pluggable[]

/**
 * Transformers modify the syntax tree or metadata of a file.
 * A transformer is a function that is called each time a file is passed
 * through the transform phase.
 * If an error occurs (either because itâ€™s thrown, returned, rejected, or passed
 * to `next`), the process stops.
 *
 * @typeParam Input
 *   Node type that the transformer expects.
 * @typeParam Output
 *   Node type that the transformer yields.
 * @param node
 *   Tree to be transformed.
 * @param file
 *   File associated with node.
 * @param next
 *   Callback that you must call when done.
 *   Note: this is given if you accept three parameters in your transformer.
 *   If you accept up to two parameters, itâ€™s not given, and you can return
 *   a promise.
 * @returns
 *   Any of the following:
 *
 *   * `void` â€” If nothing is returned, the next transformer keeps using same
 *     tree.
 *   * `Error` â€” Can be returned to stop the process.
 *   * `Node` â€” Can be returned and results in further transformations and
 *     `stringify`s to be performed on the new tree.
 *   * `Promise` â€” If a promise is returned, the function is asynchronous, and
 *      must be resolved (optionally with a `Node`) or rejected (optionally with
 *      an `Error`).
 *
 *   If you accept a `next` callback, nothing should be returned.
 */
type Transformer$1<
  Input extends Node = Node,
  Output extends Node = Input
> = (
  node: Input,
  file: VFile,
  next: TransformCallback<Output>
) => Promise<Output | undefined | void> | Output | Error | undefined | void

/**
 * Callback you must call when a transformer is done.
 *
 * @typeParam Tree
 *   Node that the plugin yields.
 * @param error
 *   Pass an error to stop the process.
 * @param node
 *   Pass a tree to continue transformations (and `stringify`) on the new tree.
 * @param file
 *   Pass a file to continue transformations (and `stringify`) on the new file.
 * @returns
 *   Nothing.
 */
type TransformCallback<Tree extends Node = Node> = (
  error?: Error | null | undefined,
  node?: Tree | undefined,
  file?: VFile | undefined
) => void

/**
 * Function handling the parsing of text to a syntax tree.
 * Used in the parse phase in the process and called with a `string` and
 * `VFile` representation of the document to parse.
 *
 * `Parser` can be a normal function, in which case it must return a `Node`:
 * the syntax tree representation of the given file.
 *
 * `Parser` can also be a constructor function (a function with keys in its
 * `prototype`), in which case itâ€™s called with `new`.
 * Instances must have a parse method that is called without arguments and
 * must return a `Node`.
 *
 * @typeParam Tree
 *   The node that the parser yields (and `run` receives).
 */
type Parser<Tree extends Node = Node> =
  | ParserClass<Tree>
  | ParserFunction<Tree>

/**
 * A class to parse files.
 *
 * @typeParam Tree
 *   The node that the parser yields.
 */
declare class ParserClass<Tree extends Node = Node> {
  prototype: {
    /**
     * Parse a file.
     *
     * @returns
     *   Parsed tree.
     */
    parse(): Tree
  }

  /**
   * Constructor.
   *
   * @param document
   *   Document to parse.
   * @param file
   *   File associated with `document`.
   * @returns
   *   Instance.
   */
  constructor(document: string, file: VFile)
}

/**
 * Normal function to parse a file.
 *
 * @typeParam Tree
 *   The node that the parser yields.
 * @param document
 *   Document to parse.
 * @param file
 *   File associated with `document`.
 * @returns
 *   Node representing the given file.
 */
type ParserFunction<Tree extends Node = Node> = (
  document: string,
  file: VFile
) => Tree

/**
 * Function handling the compilation of syntax tree to a text.
 * Used in the stringify phase in the process and called with a `Node` and
 * `VFile` representation of the document to stringify.
 *
 * `Compiler` can be a normal function, in which case it must return a
 * `string`: the text representation of the given syntax tree.
 *
 * `Compiler` can also be a constructor function (a function with keys in its
 * `prototype`), in which case itâ€™s called with `new`.
 * Instances must have a `compile` method that is called without arguments
 * and must return a `string`.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 */
type Compiler<Tree extends Node = Node, Result = unknown> =
  | CompilerClass<Tree, Result>
  | CompilerFunction<Tree, Result>

/**
 * A class to compile trees.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 */
declare class CompilerClass<Tree extends Node = Node, Result = unknown> {
  prototype: {
    /**
     * Compile a tree.
     *
     * @returns
     *   New content: compiled text (`string` or `Buffer`, for `file.value`) or
     *   something else (for `file.result`).
     */
    compile(): Result
  }

  /**
   * Constructor.
   *
   * @param tree
   *   Tree to compile.
   * @param file
   *   File associated with `tree`.
   * @returns
   *   Instance.
   */
  constructor(tree: Tree, file: VFile)
}

/**
 * Normal function to compile a tree.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 * @param tree
 *   Tree to compile.
 * @param file
 *   File associated with `tree`.
 * @returns
 *   New content: compiled text (`string` or `Buffer`, for `file.value`) or
 *   something else (for `file.result`).
 */
type CompilerFunction<Tree extends Node = Node, Result = unknown> = (
  tree: Tree,
  file: VFile
) => Result

/**
 * Callback called when a done running.
 *
 * @typeParam Tree
 *   The tree that the callback receives.
 * @param error
 *   Error passed when unsuccessful.
 * @param node
 *   Tree to transform.
 * @param file
 *   File passed when successful.
 * @returns
 *   Nothing.
 */
type RunCallback<Tree extends Node = Node> = (
  error?: Error | null | undefined,
  node?: Tree | undefined,
  file?: VFile | undefined
) => void

/**
 * Callback called when a done processing.
 *
 * @typeParam File
 *   The file that the callback receives.
 * @param error
 *   Error passed when unsuccessful.
 * @param file
 *   File passed when successful.
 * @returns
 *   Nothing.
 */
type ProcessCallback<File extends VFile = VFile> = (
  error?: Error | null | undefined,
  file?: File | undefined
) => void

declare type RemarkFFFOptions = {
    target: 'mdsvex' | 'astro';
    presets: (string | RemarkFFFPreset)[];
    autofill?: {
        provider: 'fs' | 'git';
        path?: string | ((path: string) => string);
    };
    strict?: {
        media?: {
            type?: 'string' | 'object';
            array?: boolean;
        };
    };
};
declare type RemarkFFFPreset = {
    [key in keyof FFFFlavoredFrontmatter]: string | ((fm: Frontmatter) => unknown);
};
declare type Transformer<Input extends Node = Node, Output extends Node = Input> = (node: Input, file: File, next: TransformCallback<Output>) => Promise<Output | undefined | void> | Output | Error | undefined | void;
declare type Plugin<PluginParameters extends any[] = any[], Input = Node, Output = Input> = (this: Input extends Node ? Output extends Node ? Processor<void, Input> : Processor<void, Input, Input, Output> : Output extends Node ? Processor<Output, Output> : Processor, ...settings: PluginParameters) => Input extends Node ? Output extends Node ? Transformer<Input, Output> | void : void : void;
declare type Frontmatter = FFFFlavoredFrontmatter & {
    [key: string]: unknown;
};
declare type File = /** MDsveX */ {
    filename: string;
    path: never;
    data: {
        fm: Frontmatter;
        astro: never;
    };
} | /** Astro */ {
    filename: never;
    path: string;
    data: {
        fm: never;
        astro: {
            frontmatter: Frontmatter;
        };
    };
};
declare const remarkFFF: Plugin<[RemarkFFFOptions]>;

export { RemarkFFFOptions, RemarkFFFPreset, remarkFFF as default };
