var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/presets.ts
var presets_exports = {};
__export(presets_exports, {
  hexo: () => hexo,
  hugo: () => hugo,
  zola: () => zola
});
var hugo = {
  image: "images",
  tags: "category",
  bookmark_of: "bookmarkOf",
  like_of: "likeOf",
  repost_of: "repostOf",
  in_reply_to: "inReplyTo",
  flags: ({ flags, draft, visibility }) => Array.from(
    /* @__PURE__ */ new Set([
      ...flags ?? [],
      ...draft ? ["draft"] : [],
      ...visibility ? [visibility] : []
    ])
  )
};
var hexo = {
  created: "date",
  summary: "excerpt",
  tags: ({
    tags,
    categories
  }) => [...tags, ...Array.from(new Set(categories.flat()))]
};
var zola = {
  summary: "description",
  created: "date",
  flags: ({ flags, draft }) => Array.from(/* @__PURE__ */ new Set([...flags, ...draft ? ["draft"] : []]))
};

// src/autofill.ts
var autofill_exports = {};
__export(autofill_exports, {
  fs: () => fs,
  git: () => git,
  path: () => path
});
var import_node_child_process = require("child_process");
var import_node_fs = require("fs");
var import_node_os = require("os");
var import_meta = {};
var path = {
  urara: (path2) => new URL(`./urara${path2.split("/src/routes")[1]}`, import_meta.url)
};
var fs = (path2) => {
  const { ctime, mtime } = (0, import_node_fs.statSync)(path2);
  return {
    created: ({ created }) => created ?? ctime,
    updated: ({ updated }) => updated ?? mtime
  };
};
var git = (path2) => ({
  created: ({ created }) => created ?? (0, import_node_child_process.execFileSync)(
    "git",
    ["log", "--diff-filter=A", "--follow", "--format=%ai", "--", path2],
    { encoding: "utf8" }
  ).trim().split(import_node_os.EOL).pop(),
  updated: ({ updated }) => updated ?? (0, import_node_child_process.execFileSync)("git", ["log", "-1", "--pretty=format:%ai", "--", path2], {
    encoding: "utf8"
  }).trim()
});

// src/strict.ts
var strict = (strict2) => {
  const mediaTransform = (media) => {
    let result = media;
    if (result instanceof String && strict2.media.type === "object")
      result = { src: result };
    else if (result instanceof Object && strict2.media.type === "string")
      result = result.src;
    else if (result instanceof Array) {
      result = result.map(
        (media2) => media2 instanceof String && strict2.media.type === "object" ? { src: result } : media2 instanceof Object && strict2.media.type === "string" ? media2.src : media2
      );
      if (strict2.media.array === false)
        result = result[0];
    }
    return result;
  };
  return {
    image: ({ image }) => mediaTransform(image),
    audio: ({ audio }) => mediaTransform(audio),
    video: ({ video }) => mediaTransform(video)
  };
};

// src/index.ts
var remarkFFF = (options = { presets: ["hugo"], target: "mdsvex" }) => (_tree, file) => {
  var _a;
  const path2 = file.filename ?? file.path;
  let fm = {
    ...options.target === "mdsvex" ? file.data.fm : file.data.astro.frontmatter
  };
  [
    ...options.presets,
    ...((_a = options.autofill) == null ? void 0 : _a.provider) ? [
      autofill_exports[options.autofill.provider](
        options.autofill.path ? options.autofill.path instanceof Function ? options.autofill.path(path2) : path[options.autofill.path](path2) : file.filename
      )
    ] : [],
    ...options.strict ? [strict(options.strict)] : []
  ].forEach(
    (preset) => Object.entries(
      preset instanceof Object ? preset : presets_exports[preset]
    ).forEach(
      ([output, input]) => fm = {
        ...fm,
        [output]: input instanceof Function ? input(fm) : fm[input] ?? fm[output]
      }
    )
  );
  if (options.target === "mdsvex")
    file.data.fm = fm;
  else if (options.target === "astro")
    file.data.astro.frontmatter = fm;
};
var src_default = remarkFFF;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
