var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/presets.ts
var presets_exports = {};
__export(presets_exports, {
  hexo: () => hexo,
  hugo: () => hugo,
  zola: () => zola
});
var hugo = {
  image: "images",
  tags: "category",
  bookmark_of: "bookmarkOf",
  like_of: "likeOf",
  repost_of: "repostOf",
  in_reply_to: "inReplyTo",
  flags: ({ flags, draft, visibility }) => Array.from(
    /* @__PURE__ */ new Set([
      ...flags ?? [],
      ...draft ? ["draft"] : [],
      ...visibility ? [visibility] : []
    ])
  )
};
var hexo = {
  created: "date",
  summary: "excerpt",
  tags: ({
    tags,
    categories
  }) => [...tags, ...Array.from(new Set(categories.flat()))]
};
var zola = {
  summary: "description",
  created: "date",
  flags: ({ flags, draft }) => Array.from(/* @__PURE__ */ new Set([...flags, ...draft ? ["draft"] : []]))
};

// src/autofill.ts
var autofill_exports = {};
__export(autofill_exports, {
  fs: () => fs,
  git: () => git,
  path: () => path
});
import { execFileSync } from "child_process";
import { statSync } from "fs";
import { EOL } from "os";
var path = {
  urara: (path2) => new URL(`./urara${path2.split("/src/routes")[1]}`, import.meta.url)
};
var fs = (path2) => {
  const { ctime, mtime } = statSync(path2);
  return {
    created: ({ created }) => created ?? ctime,
    updated: ({ updated }) => updated ?? mtime
  };
};
var git = (path2) => ({
  created: ({ created }) => created ?? execFileSync(
    "git",
    ["log", "--diff-filter=A", "--follow", "--format=%ai", "--", path2],
    { encoding: "utf8" }
  ).trim().split(EOL).pop(),
  updated: ({ updated }) => updated ?? execFileSync("git", ["log", "-1", "--pretty=format:%ai", "--", path2], {
    encoding: "utf8"
  }).trim()
});

// src/strict.ts
var strict = (strict2) => {
  const mediaTransform = (media) => {
    let result = media;
    if (result instanceof String && strict2.media.type === "object")
      result = { src: result };
    else if (result instanceof Object && strict2.media.type === "string")
      result = result.src;
    else if (result instanceof Array) {
      result = result.map(
        (media2) => media2 instanceof String && strict2.media.type === "object" ? { src: result } : media2 instanceof Object && strict2.media.type === "string" ? media2.src : media2
      );
      if (strict2.media.array === false)
        result = result[0];
    }
    return result;
  };
  return {
    image: ({ image }) => mediaTransform(image),
    audio: ({ audio }) => mediaTransform(audio),
    video: ({ video }) => mediaTransform(video)
  };
};

// src/index.ts
var remarkFFF = (options = { presets: ["hugo"], target: "mdsvex" }) => (_tree, file) => {
  var _a;
  const path2 = file.filename ?? file.path;
  let fm = {
    ...options.target === "mdsvex" ? file.data.fm : file.data.astro.frontmatter
  };
  [
    ...options.presets,
    ...((_a = options.autofill) == null ? void 0 : _a.provider) ? [
      autofill_exports[options.autofill.provider](
        options.autofill.path ? options.autofill.path instanceof Function ? options.autofill.path(path2) : path[options.autofill.path](path2) : file.filename
      )
    ] : [],
    ...options.strict ? [strict(options.strict)] : []
  ].forEach(
    (preset) => Object.entries(
      preset instanceof Object ? preset : presets_exports[preset]
    ).forEach(
      ([output, input]) => fm = {
        ...fm,
        [output]: input instanceof Function ? input(fm) : fm[input] ?? fm[output]
      }
    )
  );
  if (options.target === "mdsvex")
    file.data.fm = fm;
  else if (options.target === "astro")
    file.data.astro.frontmatter = fm;
};
var src_default = remarkFFF;
export {
  src_default as default
};
