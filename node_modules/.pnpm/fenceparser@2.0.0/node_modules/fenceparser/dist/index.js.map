{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/Lexer.ts", "../src/Parser.ts", "../src/index.ts"],
  "sourcesContent": ["export type Token = string | number | boolean\n\nexport const isQuoted = (s: string) => {\n  const first = s[0]\n  const last = s[s.length - 1]\n\n  return s.length > 1 && first === last && (first === '\"' || last === \"'\")\n}\n\nexport class Iterator<T extends string | Array<Token>> {\n  protected error(err: string) {\n    throw new Error(`Fenceparser: ${err}.`)\n  }\n\n  protected start = 0\n  protected current = 0\n\n  protected peek(n?: number): T[number] {\n    return this.input[this.current + (n ?? 0)]\n  }\n\n  protected advance(): T[number] {\n    return this.input[this.current++]\n  }\n\n  protected isAtEnd() {\n    return this.current >= this.input.length\n  }\n\n  public constructor(protected readonly input: T) {}\n}\n", "import {Iterator, Token} from './utils'\n\nexport const lex = (input: string) => new Lexer(input).scan()\n\nconst KEYWORDS: Record<string, Token> = {\n  true: true,\n  false: false\n}\n\nconst isAlpha = (s: string) => /[a-zA-Z_$-]/.test(s)\nconst isNumeric = (s: string) => /[0-9]/.test(s)\nconst isAlphaNumeric = (s: string) => isAlpha(s) || isNumeric(s)\n\nclass Lexer extends Iterator<string> {\n  private output: Array<Token> = []\n\n  private string(quote: string) {\n    while (this.peek() !== quote && !this.isAtEnd()) this.advance()\n\n    if (this.isAtEnd()) {\n      this.error('Unterminated string')\n    }\n\n    this.advance()\n    this.output.push(this.input.substring(this.start, this.current))\n  }\n\n  private number() {\n    while (isNumeric(this.peek()) && !this.isAtEnd()) this.advance()\n\n    if (this.peek() === '-' && isNumeric(this.peek(1))) {\n      this.advance()\n      while (isNumeric(this.peek())) this.advance()\n      this.output.push(this.input.substring(this.start, this.current))\n      return\n    } else if (this.peek() === '.' && isNumeric(this.peek(1))) {\n      this.advance()\n      while (isNumeric(this.peek())) this.advance()\n    }\n\n    this.output.push(parseFloat(this.input.substring(this.start, this.current)))\n  }\n\n  private identifier() {\n    while (isAlphaNumeric(this.peek()) && !this.isAtEnd()) this.advance()\n\n    const text = this.input.substring(this.start, this.current)\n    if (Object.keys(KEYWORDS).includes(text)) {\n      this.output.push(KEYWORDS[text])\n    } else {\n      this.output.push(text)\n    }\n  }\n\n  public scan() {\n    while (!this.isAtEnd()) {\n      this.start = this.current\n\n      const next = this.advance()\n      switch (next) {\n        case '{':\n        case '}':\n        case '=':\n        case ',':\n        case ':':\n        case '[':\n        case ']':\n          this.output.push(next)\n          break\n        case '\"':\n        case \"'\":\n          this.string(next)\n          break\n        case ' ':\n        case '\\r':\n        case '\\t':\n        case '\\n':\n          break\n        default:\n          if (isNumeric(next)) {\n            this.number()\n          } else if (isAlpha(next)) {\n            this.identifier()\n          } else {\n            this.error(`Unexpected character ${next}`)\n          }\n      }\n    }\n\n    return this.output\n  }\n}\n", "import {isQuoted, Iterator, Token} from './utils'\n\n// Grammar - Recursive Descent\n//\n// MAIN \u2192 EXPR*\n// EXPR \u2192 OBJECT | IDENTIFIER (= VALUE)?\n//\n// OBJECT \u2192 { OBJECT_VALUES? }\n// OBJECT_VALUES \u2192 OBJECT_VALUE (, OBJECT_VALUE)*\n// OBJECT_VALUE \u2192 NUMBER | IDENTIFIER | (IDENTIFIER | STRING | NUMBER): VALUE\n//\n// ARRAY \u2192 [ ARRAY_VALUES? ]\n// ARRAY_VALUES \u2192 (ARRAY_VALUE) (ARRAY_VALUE)*\n// ARRAY_VALUE \u2192 VALUE\n//\n// VALUE \u2192 IDENTIFIER | OBJECT | ARRAY | (\"|') STRING (\"|') | BOOLEAN | NUMBER\n// IDENTIFIER \u2192 STRING\n\nexport type OBJECT = {[key in string | number]: VALUE}\nexport type VALUE = OBJECT | Array<VALUE> | string | boolean | number\n\nexport const parse = (input: Array<Token>) => new Parser(input).parse()\n\nclass Parser extends Iterator<Array<Token>> {\n  private output: Record<string, VALUE> = {}\n\n  private object() {\n    const result: OBJECT = {}\n    const parseValue = () => {\n      let identifier = this.advance()\n\n      if (typeof identifier === 'number') {\n        identifier = identifier as number\n      } else if (typeof identifier === 'string' && isQuoted(identifier)) {\n        identifier = identifier.slice(1, -1)\n      }\n      identifier = identifier as string\n\n      if (this.peek() === ':') {\n        this.advance()\n        result[identifier] = this.value()\n      } else {\n        result[identifier] = true\n      }\n    }\n\n    this.advance()\n    if (this.peek() !== '}') {\n      parseValue()\n      while (this.peek() === ',') {\n        this.advance()\n        if (this.peek() === '}') {\n          this.error('Trailing comma')\n        }\n        parseValue()\n      }\n    }\n\n    if (this.advance() !== '}') {\n      this.error('Unterminated object')\n    }\n    return result\n  }\n\n  private array() {\n    const result: Array<VALUE> = []\n\n    this.advance()\n    if (this.peek() !== ']') {\n      result.push(this.value())\n      while (this.peek() === ',') {\n        this.advance()\n        if (this.peek() === ']') {\n          this.error('Trailing comma')\n        }\n        result.push(this.value())\n      }\n    }\n    if (this.advance() !== ']') {\n      this.error('Unterminated array')\n    }\n    return result\n  }\n\n  private value(): VALUE {\n    if (this.peek() === '{') {\n      return this.object()\n    } else if (this.peek() === '[') {\n      return this.array()\n    } else if (\n      typeof this.peek() === 'string' &&\n      isQuoted(this.peek() as string)\n    ) {\n      return (this.advance() as string).slice(1, -1)\n    } else {\n      return this.advance()\n    }\n  }\n\n  public parse() {\n    if (this.input.length < 1) {\n      return null\n    }\n\n    while (!this.isAtEnd()) {\n      const peeked = this.peek()\n\n      if (peeked === '{') {\n        if (!this.output.highlight) {\n          this.output.highlight = {}\n        }\n\n        this.output.highlight = {\n          ...(this.output.highlight as OBJECT),\n          ...this.object()\n        }\n      } else {\n        const identifier = this.advance() as string\n\n        if (this.peek() === '=') {\n          this.advance()\n          this.output[identifier] = this.value()\n        } else {\n          this.output[identifier] = true\n        }\n      }\n    }\n\n    return this.output\n  }\n}\n", "import {lex} from './Lexer'\nimport {parse} from './Parser'\n\nexport {lex, parse}\nexport default (input: string) => parse(lex(input))\n"],
  "mappings": "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",
  "names": []
}
