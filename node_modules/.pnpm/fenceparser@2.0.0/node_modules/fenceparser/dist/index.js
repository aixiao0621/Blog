var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils.ts
var isQuoted = (s) => {
  const first = s[0];
  const last = s[s.length - 1];
  return s.length > 1 && first === last && (first === '"' || last === "'");
};
var Iterator = class {
  constructor(input) {
    this.input = input;
    __publicField(this, "start", 0);
    __publicField(this, "current", 0);
  }
  error(err) {
    throw new Error(`Fenceparser: ${err}.`);
  }
  peek(n) {
    return this.input[this.current + (n != null ? n : 0)];
  }
  advance() {
    return this.input[this.current++];
  }
  isAtEnd() {
    return this.current >= this.input.length;
  }
};

// src/Lexer.ts
var lex = (input) => new Lexer(input).scan();
var KEYWORDS = {
  true: true,
  false: false
};
var isAlpha = (s) => /[a-zA-Z_$-]/.test(s);
var isNumeric = (s) => /[0-9]/.test(s);
var isAlphaNumeric = (s) => isAlpha(s) || isNumeric(s);
var Lexer = class extends Iterator {
  constructor() {
    super(...arguments);
    __publicField(this, "output", []);
  }
  string(quote) {
    while (this.peek() !== quote && !this.isAtEnd())
      this.advance();
    if (this.isAtEnd()) {
      this.error("Unterminated string");
    }
    this.advance();
    this.output.push(this.input.substring(this.start, this.current));
  }
  number() {
    while (isNumeric(this.peek()) && !this.isAtEnd())
      this.advance();
    if (this.peek() === "-" && isNumeric(this.peek(1))) {
      this.advance();
      while (isNumeric(this.peek()))
        this.advance();
      this.output.push(this.input.substring(this.start, this.current));
      return;
    } else if (this.peek() === "." && isNumeric(this.peek(1))) {
      this.advance();
      while (isNumeric(this.peek()))
        this.advance();
    }
    this.output.push(parseFloat(this.input.substring(this.start, this.current)));
  }
  identifier() {
    while (isAlphaNumeric(this.peek()) && !this.isAtEnd())
      this.advance();
    const text = this.input.substring(this.start, this.current);
    if (Object.keys(KEYWORDS).includes(text)) {
      this.output.push(KEYWORDS[text]);
    } else {
      this.output.push(text);
    }
  }
  scan() {
    while (!this.isAtEnd()) {
      this.start = this.current;
      const next = this.advance();
      switch (next) {
        case "{":
        case "}":
        case "=":
        case ",":
        case ":":
        case "[":
        case "]":
          this.output.push(next);
          break;
        case '"':
        case "'":
          this.string(next);
          break;
        case " ":
        case "\r":
        case "	":
        case "\n":
          break;
        default:
          if (isNumeric(next)) {
            this.number();
          } else if (isAlpha(next)) {
            this.identifier();
          } else {
            this.error(`Unexpected character ${next}`);
          }
      }
    }
    return this.output;
  }
};

// src/Parser.ts
var parse = (input) => new Parser(input).parse();
var Parser = class extends Iterator {
  constructor() {
    super(...arguments);
    __publicField(this, "output", {});
  }
  object() {
    const result = {};
    const parseValue = () => {
      let identifier = this.advance();
      if (typeof identifier === "number") {
        identifier = identifier;
      } else if (typeof identifier === "string" && isQuoted(identifier)) {
        identifier = identifier.slice(1, -1);
      }
      identifier = identifier;
      if (this.peek() === ":") {
        this.advance();
        result[identifier] = this.value();
      } else {
        result[identifier] = true;
      }
    };
    this.advance();
    if (this.peek() !== "}") {
      parseValue();
      while (this.peek() === ",") {
        this.advance();
        if (this.peek() === "}") {
          this.error("Trailing comma");
        }
        parseValue();
      }
    }
    if (this.advance() !== "}") {
      this.error("Unterminated object");
    }
    return result;
  }
  array() {
    const result = [];
    this.advance();
    if (this.peek() !== "]") {
      result.push(this.value());
      while (this.peek() === ",") {
        this.advance();
        if (this.peek() === "]") {
          this.error("Trailing comma");
        }
        result.push(this.value());
      }
    }
    if (this.advance() !== "]") {
      this.error("Unterminated array");
    }
    return result;
  }
  value() {
    if (this.peek() === "{") {
      return this.object();
    } else if (this.peek() === "[") {
      return this.array();
    } else if (typeof this.peek() === "string" && isQuoted(this.peek())) {
      return this.advance().slice(1, -1);
    } else {
      return this.advance();
    }
  }
  parse() {
    if (this.input.length < 1) {
      return null;
    }
    while (!this.isAtEnd()) {
      const peeked = this.peek();
      if (peeked === "{") {
        if (!this.output.highlight) {
          this.output.highlight = {};
        }
        this.output.highlight = __spreadValues(__spreadValues({}, this.output.highlight), this.object());
      } else {
        const identifier = this.advance();
        if (this.peek() === "=") {
          this.advance();
          this.output[identifier] = this.value();
        } else {
          this.output[identifier] = true;
        }
      }
    }
    return this.output;
  }
};

// src/index.ts
var src_default = (input) => parse(lex(input));
export {
  src_default as default,
  lex,
  parse
};
//# sourceMappingURL=index.js.map
